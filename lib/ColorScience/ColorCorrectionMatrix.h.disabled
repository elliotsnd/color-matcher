/*!
 * @file ColorCorrectionMatrix.h
 * @brief Professional Color Correction Matrix (CCM) Implementation
 * @copyright Professional Color Calibration System
 * @version 2.0
 * @date 2024
 * 
 * Implements calibration-driven color conversion using a custom 3x3 Color Correction Matrix
 * derived from professional reference samples. This replaces the flawed interpolation approach
 * with industry-standard colorimetric transformation.
 */

#pragma once

#include "ColorScienceCompat.h"
#include "GroundTruthColors.h"

namespace ColorCalibration {

/**
 * @brief 3x3 Matrix structure for color correction
 */
struct Matrix3x3 {
    float m[3][3];
    
    /**
     * @brief Default constructor - initializes to identity matrix
     */
    Matrix3x3() {
        // Initialize to identity matrix
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                m[i][j] = (i == j) ? 1.0f : 0.0f;
            }
        }
    }
    
    /**
     * @brief Calculate the determinant of the matrix
     * @return Determinant value
     */
    float determinant() const {
        return m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2]) -
               m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
               m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
    }
    
    /**
     * @brief Calculate the inverse of this matrix
     * @return Inverted matrix (identity if non-invertible)
     */
    Matrix3x3 inverse() const {
        Matrix3x3 inv;
        float det = determinant();
        
        if (abs(det) < 1e-9f) {
            // Matrix is not invertible, return identity
            return inv;
        }
        
        float invdet = 1.0f / det;
        
        // Calculate inverse using cofactor method
        inv.m[0][0] = (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * invdet;
        inv.m[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * invdet;
        inv.m[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * invdet;
        inv.m[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) * invdet;
        inv.m[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * invdet;
        inv.m[1][2] = (m[1][0] * m[0][2] - m[0][0] * m[1][2]) * invdet;
        inv.m[2][0] = (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * invdet;
        inv.m[2][1] = (m[2][0] * m[0][1] - m[0][0] * m[2][1]) * invdet;
        inv.m[2][2] = (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * invdet;
        
        return inv;
    }
    
    /**
     * @brief Matrix multiplication
     * @param other Matrix to multiply with
     * @return Result of this * other
     */
    Matrix3x3 multiply(const Matrix3x3& other) const {
        Matrix3x3 result;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                result.m[i][j] = 0;
                for (int k = 0; k < 3; k++) {
                    result.m[i][j] += m[i][k] * other.m[k][j];
                }
            }
        }
        return result;
    }
    
    /**
     * @brief Apply matrix transformation to XYZ vector
     * @param x X component
     * @param y Y component  
     * @param z Z component
     * @param outR Output R component
     * @param outG Output G component
     * @param outB Output B component
     */
    void transform(float x, float y, float z, float& outR, float& outG, float& outB) const {
        outR = m[0][0] * x + m[0][1] * y + m[0][2] * z;
        outG = m[1][0] * x + m[1][1] * y + m[1][2] * z;
        outB = m[2][0] * x + m[2][1] * y + m[2][2] * z;
    }
    
    /**
     * @brief Get matrix as string for debugging
     * @return String representation of matrix
     */
    String toString() const {
        String result = "[\n";
        for (int i = 0; i < 3; i++) {
            result += "  [" + String(m[i][0], 4) + ", " + String(m[i][1], 4) + ", " + String(m[i][2], 4) + "]\n";
        }
        result += "]";
        return result;
    }
};

/**
 * @brief Color Correction Matrix Manager
 * 
 * Manages the generation and application of custom Color Correction Matrices
 * based on professional calibration reference samples.
 */
class ColorCorrectionMatrixManager {
private:
    Matrix3x3 colorCorrectionMatrix_;
    bool isCCMCalibrated_;
    float calibrationQuality_;
    
public:
    /**
     * @brief Constructor
     */
    ColorCorrectionMatrixManager() : isCCMCalibrated_(false), calibrationQuality_(0.0f) {}
    
    /**
     * @brief Generate Color Correction Matrix from calibration data
     * @param calibData Enhanced calibration data with 4-point references
     * @return true if CCM generation successful
     */
    bool generateColorCorrectionMatrix(const EnhancedCalibrationData& calibData);
    
    /**
     * @brief Apply Color Correction Matrix to convert XYZ to RGB
     * @param X Sensor X reading
     * @param Y Sensor Y reading
     * @param Z Sensor Z reading
     * @param R Output red component (0-255)
     * @param G Output green component (0-255)
     * @param B Output blue component (0-255)
     * @return true if conversion successful
     */
    bool applyColorCorrectionMatrix(uint16_t X, uint16_t Y, uint16_t Z, 
                                   uint8_t& R, uint8_t& G, uint8_t& B) const;
    
    /**
     * @brief Check if CCM is calibrated and ready
     * @return true if CCM is calibrated
     */
    bool isCalibrated() const { return isCCMCalibrated_; }
    
    /**
     * @brief Get calibration quality score
     * @return Quality score (0.0-100.0)
     */
    float getCalibrationQuality() const { return calibrationQuality_; }
    
    /**
     * @brief Get the current Color Correction Matrix
     * @return Current CCM
     */
    const Matrix3x3& getMatrix() const { return colorCorrectionMatrix_; }
    
    /**
     * @brief Reset CCM calibration
     */
    void reset() { 
        isCCMCalibrated_ = false; 
        calibrationQuality_ = 0.0f;
        colorCorrectionMatrix_ = Matrix3x3(); // Reset to identity
    }
    
    /**
     * @brief Validate CCM against ground truth
     * @param calibData Calibration data to validate against
     * @return Validation quality score
     */
    float validateCCM(const EnhancedCalibrationData& calibData) const;
};

/**
 * @brief Professional RGB conversion using Color Correction Matrix
 *
 * This is the ONLY color conversion function needed after CCM calibration.
 * Replaces all legacy convertXyZtoRgb... functions with professional accuracy.
 *
 * @param X Sensor X reading
 * @param Y Sensor Y reading
 * @param Z Sensor Z reading
 * @param R Output red component (0-255)
 * @param G Output green component (0-255)
 * @param B Output blue component (0-255)
 */
void getRgbFromXyzCCM(uint16_t X, uint16_t Y, uint16_t Z, uint8_t& R, uint8_t& G, uint8_t& B);

// Global CCM manager instance
extern ColorCorrectionMatrixManager ccmManager;

} // namespace ColorCalibration
